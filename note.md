# UVa1585 Score

> 2018 - 1 - 14

# UVa1586 Molar Mass

> 2018 - 1 - 14

# UVa1225 Digit Counting

> 2018 - 1 - 14

# UVa455 Periodic Strings

> 2018 - 1 - 14

# UVa227 Puzzle

> 2018 - 1 - 14

cin.getline()等函数应用，输出格式控制

# UVa232 Crossword Answers

> 2018 - 1 - 15

# UVa1368 DNA Consensus String

> 2018 - 1 - 15

Runtime error 注意数组超界问题

# UVa232 The Dole Queue

> 2018 - 1 - 15

注意约瑟夫环，取余环形遍历数组的技巧。

# UVa202 Repeating Decimals

> 2018 - 1 - 16

超级痛苦的AC，第一道一开始看没思路的题，而且乍一看特别简单。
辗转相除法的应用。

# UVa10340 All in All

> 2018 - 1 - 16

# UVa1587 Box

> 2018 - 1 - 16

# UVa1588 Kickdown

> 2018 - 1 - 16

忘记减去‘0’。

# UVa11809 Floating-Point Numbers

> 2018 - 1 - 17

对大数取对数，查表。

# UVa1339 Ancient Cipher

> 2018 - 1 - 17

别打错变量名字。

# UVa489 Hangman Judge

> 2018 - 1 - 18

# UVa213 Message Decoding

> 2018 - 1 - 19

本题注意getchar()函数的使用。
 
# UVa512 Spreadsheet Tracking

> 2018 - 1 - 20

对着书上敲得，好不容易调试OK。

重点是，每行的指令同时执行，不会再删除某一行后，影响后面的，所以用新的表格储存指令得到的结果，方程前面推的影响后面。

# UVa12412 A Typical Homework

> 2018 - 1 - 26

解锁新技能：uDebug。

本题注意输入输出重定向记得打注释。

除数记得检查为0，样例给的都会很坑！！！

浮点数误差，记得使用EPS，防止精度问题。

注意别被格式坑了！

# UVa1589 Xiangqi

> 2018 - 1 - 27

又是一个把我搞得快崩溃的题，一开始没有把问题考虑好，采用边输入边检查攻击范围，没有考虑到后面的棋子。

第二个问题，黑将可以吃子的问题，采用的解决方法是车和炮的攻击范围，从一开始会被棋子打断（该位置不在范围），到包括该位置，即假如黑将吃了这个棋子，那么就进入攻击范围。

第三，又忘记把红将也设置为红车进行判定，这才把所有情况考虑周到，但是又忘记删掉重定向，最后才AC。

# UVa201 Squares

> 2018 - 1 - 27

敲开心！一发AC！

暴力数正方形的时候差点忘记了有两个横边，两个竖边

# UVa220 Othello

> 2018 - 1 - 28

这种棋啊什么玩意的题目是真的烦，情况没考虑好就要WA，而且对于我这种弱鸡代码写的非常冗余。

本题输出有很多坑，uDebug调试AC后，竟然还是WA。

无奈拿着这个代码自己和自己下黑白棋，最后无意间发现在边界的时候会有迷之吃子。

虽然分析代码后，发现问题不大？还是最后加了宏is进行判断，终于AC。

写的太丑了Orz。




# UVa572 Oil Deposits

> 2018 - 3 - 11

DFS求联通块。

# UVa679 Dropping Balls

> 2018 - 3 - 12

参考紫书证明。

# UVa122 Trees on the level

> 2018 - 3 - 13

一开始写的指针实现的版本，貌似存在内存泄漏问题，输入之间有蜜汁相互作用，后改为数组实现，AC。

# UVa548 Tree

> 2018 - 3 - 15

看的紫书的代码，建树过程主要通过build函数，传递4个参数，中序遍历起点、终点，后序遍历起点、终点，递归地建出整个树，注意到，后序遍历的最后一个数据为当前子树的根节点，在中序遍历结果中找到该节点，可以得到该节点左边范围为左子树，右边为右子树。此时开left和right两个数组，直接对权值进行编号，数据记录了左右儿子的序号，也就是左右儿子的权值。由此进行递归，将当前节点的左右儿子用build函数赋值，分别递归左子树和右子树，同时函数本身最后会返回当前根节点的权值。递归终止条件为，中序遍历起点大于终点（不知道为什么紫书没写后序遍历的起点终点关系）。

# UVa839 Not so Mobile

> 2018 - 3 - 19

一开始，自己题意貌似理解错误，物理太差了。

瞅了一眼紫书的源码，才明白自己原来写的有问题，忽略了对支点的考虑，而且也不需要开数组存整棵树。

紫书源码，精妙之处在于对每个节点质量更新的处理，使用了引用，更深处的递归的质量变化将会更新当前节点的质量。

# UVa699 The Falling Leaves

> 2018 - 3 - 20

建树，忘记了。

# UVa1103 Ancient Messages 

> 2018 - 3 - 20

复杂的DFS求联通块并染色。

# UVa10305 Ordering Tasks

> 2018 - 3 - 26

使用邻接矩阵建图，开一个vis数组记录节点是否被访问。

从第一个节点开始遍历，只要此节点未被访问过，则对其进行dfs。

dfs过程中，先对正在访问的节点记录为-1，则当后面dfs深入时，遇到指向的节点vis值为-1，则出现了环图，返回false，并逐层将false返回，每个节点的所有后继访问结束时，将vis值置为1，即已经被访问，之后到达dfs最深层次即为拓扑排序的尾部节点，并且如此层层搭建到顶端。

# UVa10129 Play on Words

> 2018 - 3 - 27

首先题目给了一个有向图，对于一个有向图的欧拉回路，要求每个节点的入度等于出度或者存在两个点入度出度相差1。

然后将图恢复为无向图，使用dfs判断图的联通性。

# UVa253 Cube Painting

> 2018 - 5 - 21

建立一个位置坐标，用pair储存相对颜色，模拟骰子旋转过程即可。

# UVa10763 Foreign Exchange

> 2018 - 5 - 22

建立map关联一组交换方向和其交换的人数，遍历判断是否来回相等。

**本题注意map的使用，C++11标准的容器遍历，auto类型。**

# UVa10391 Compound Words

> 2018 - 5 - 25

 注意：string和set的使用。

 10391-1：没有按照字典序输出。

 # UVa1595 Symmetry

 > 2018 - 5 - 27

 水题，对称轴取最左边和最右边的对称轴，扫一遍，二分找对称点。

 # UVa1590 IP Networks

 > 2018 - 5 - 28

 本题注意题意的理解，位运算操作的运用，**-1 = 0xFFFFFFF**。

# UVa12100 Printer Queue

> 2018 - 5 - 29

队列的模拟。

# UVa673 Parentheses Balance

> 2018 - 5 - 29

括号匹配，注意判断匹配栈非空。

# UVa712 S-Trees

> 2018 - 5 - 29

满二叉树的二进制应用。

# UVa230 Borrowers

> 2018 - 5 - 29

注意getline函数对string的应用，多种数据结构结合，模拟过程。

# UVa536 Tree Recovery

> 2018 - 5 - 29

树的先序遍历和中序遍历重建树，输出后序遍历。

**注意递归建树过程，注意边界条件，即空子树情况。**

# UVa439 Knight Moves

> 2018 - 6 - 2

bfs模拟。

# UVa1600 Patrol Robot

> 2018 - 6 - 2

复杂的bfs问题，对于图上的障碍物最多可以连续走k次，直接地打vis数组的bfs会wa。

由于在一块联通的障碍物中移动多次，并非是最优的，需要对联通障碍物区域进行单独考虑，建立obs数组记录到达每个位置的最小走障碍次数，优化后AC。

P.S：都快忘记struct的构造了Orz。

# <font color=red>UVa12166 Equilibrium Mobile</font>

> 2018 - 6 - 3

本题感觉偏脑洞题，是一道数据结构好题，一开始想思路想了很久，但是TLE了。

TLE思路：显然，解必定大于等于0，小于n（叶子节点个数），至少可以固定一个去确定其他所有节点，那么我们遍历每一个叶子节点开始检查，回溯到根节点计算这一个过程一共修改了多少次，最后取修改次数的最小值。由于重量值上限接近于INT_MAX，那么在检查时很容易在判断祖先节点时爆出int范围，故wa，修改后答案正确，但是超时，分析复杂度O(n^2)，因为要遍历每个节点，在以此为基准遍历其他所有节点。

查了一波题解获得正确思路。同以上思路，更进一步注意到，当确定一个基准时，其他所有节点的重量都与基准和高度有关，基准的兄弟应该相等，基准的父亲和其兄弟的重量等于基准的两倍，以此类推。那么，使用dfs建树，过程中记录下每个节点的高度，扫描原序列，遇到'['，那么遍历他的两个孩子节点，遇到数组则将这个数字w * 2 ^ height，即 w << height，得到这个节点放在根节点处的重量，map记录根节点出现这个重量的次数。最后，在O(n)的时间内完成扫描后，遍历这个map，取得一个最大键值，代表了以某个重量为基准在叶子节点中出现次数最多，即修改次数最小。

# UVa804 Petri Net Simulation

> 2018 - 6 - 4

本题模拟过程即可，主要由于题目所给样例的答案唯一，因此一开始我考虑dfs跑所有情况，但实际上每步的选择对答案无影响，这个地方不知道怎么证明。

本题还有一个敲代码的问题在于，不能直接将很多map组在一起直接通过数组下标访问，会有迷之段错误，不是很懂。

